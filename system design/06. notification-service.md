<!-- TOC -->
* [Notification System Design (Kafka-based)](#notification-system-design-kafka-based)
  * [1. Why a Notification System Exists (Real Usage)](#1-why-a-notification-system-exists-real-usage)
    * [Real-world example: Order placed](#real-world-example-order-placed)
  * [2. Core Design Principle](#2-core-design-principle)
  * [3. High-Level Architecture](#3-high-level-architecture)
  * [4. How a Business Service (Order Service) Interacts With the System](#4-how-a-business-service-order-service-interacts-with-the-system)
    * [What the Order Service Does](#what-the-order-service-does)
    * [Order Service ‚Üí Notification API Call](#order-service--notification-api-call)
  * [5. Notification API (Ingress Layer)](#5-notification-api-ingress-layer)
    * [Where This Executes](#where-this-executes)
    * [Responsibilities (Strict)](#responsibilities-strict)
  * [6. Rate Limiting (Critical and Explicit)](#6-rate-limiting-critical-and-explicit)
    * [Why Rate Limiting Exists](#why-rate-limiting-exists)
    * [Where Rate Limiting MUST Happen](#where-rate-limiting-must-happen)
    * [Why Workers Must NOT Rate Limit](#why-workers-must-not-rate-limit)
    * [Rate Limiting Dimensions](#rate-limiting-dimensions)
    * [Rate Limiting Pseudocode (Notification API)](#rate-limiting-pseudocode-notification-api)
  * [7. How notificationId Is Generated (Explicit)](#7-how-notificationid-is-generated-explicit)
    * [Where It Happens](#where-it-happens)
    * [How It Is Generated](#how-it-is-generated)
  * [8. Canonical Notification Message (Final)](#8-canonical-notification-message-final)
  * [9. Kafka Topic Design (Time as State)](#9-kafka-topic-design-time-as-state)
  * [10. Partitioning Strategy](#10-partitioning-strategy)
  * [11. Idempotency (Correctly Explained)](#11-idempotency-correctly-explained)
    * [Core Problem](#core-problem)
    * [What Idempotency Means Here](#what-idempotency-means-here)
    * [How It Works](#how-it-works)
  * [12. Notification Worker (Execution Layer)](#12-notification-worker-execution-layer)
    * [Where This Executes](#where-this-executes-1)
  * [13. Worker Execution Logic (Exact)](#13-worker-execution-logic-exact)
  * [14. Provider Response Handling (Meaning)](#14-provider-response-handling-meaning-)
  * [15. Retry Topic Mapping](#15-retry-topic-mapping)
  * [16. Offset Commit Strategy](#16-offset-commit-strategy)
  * [17. Guarantees (Be Precise)](#17-guarantees-be-precise)
    * [What the system guarantees](#what-the-system-guarantees)
    * [What it does NOT guarantee](#what-it-does-not-guarantee)
  * [18. Failure Scenarios](#18-failure-scenarios)
<!-- TOC -->

# Notification System Design (Kafka-based)

## 1. Why a Notification System Exists (Real Usage)

### Real-world example: Order placed

When a user places an order:

* Email ‚Üí Order confirmation
* SMS ‚Üí Order ID
* Push ‚Üí Track your order

Important design rule

üëâ The Order Service must NOT send notifications directly


Why?

* Email/SMS providers are slow & unreliable
* Failures should not fail business logic
* Retries, throttling, vendor logic do not belong in business services

So we introduce a shared infrastructure service:
>
> Notification Service
>

Used by:

* Order Service
* Payment Service
* Auth Service (OTP)
* Marketing Service


## 2. Core Design Principle

> Notification delivery must be asynchronous, durable, rate-limited, and retryable
> 

This single sentence drives the entire architecture.


## 3. High-Level Architecture

```text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Business Svc  ‚îÇ  (Order, Auth, Payment)
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ‚îÇ  HTTP / gRPC
        ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Notification API       ‚îÇ
‚îÇ - validation           ‚îÇ
‚îÇ - rate limiting        ‚îÇ
‚îÇ - enqueue only         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ
           ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Kafka                                    ‚îÇ
‚îÇ  notification.main                       ‚îÇ
‚îÇ  notification.retry.1m                   ‚îÇ
‚îÇ  notification.retry.5m                   ‚îÇ
‚îÇ  notification.retry.30m                  ‚îÇ
‚îÇ  notification.dlq                        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ
           ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Notification Workers   ‚îÇ
‚îÇ - consume              ‚îÇ
‚îÇ - idempotency          ‚îÇ
‚îÇ - provider send        ‚îÇ
‚îÇ - retry / DLQ routing  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ
           ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ External Providers     ‚îÇ
‚îÇ Email / SMS / Push     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## 4. How a Business Service (Order Service) Interacts With the System

**Execution Context**

üëâ Inside **Order Service**, after the order transaction commits successfully.

At this point:

* The order is already placed
* Notification is **best-effort**
* Order correctness does **not** depend on notification success

---

### What the Order Service Does

The Order Service performs **exactly one action**:

>
> It submits a notification intent to the Notification API.
> 

It does not:

* talk to email/SMS providers
* retry notifications
* handle failures
* manage rate limits
 
---

### Order Service ‚Üí Notification API Call

```text
POST /notifications
{
  "userId": 101,
  "event": "ORDER_CONFIRMED",
  "channels": ["EMAIL", "SMS"],
  "payload": {
    "orderId": 456
  }
}
```

This request expresses intent only:

> "The system should attempt to notify the user about this order."
> 

Once this request is sent:

* Order Service is done
* No coupling to delivery outcome


## 5. Notification API (Ingress Layer)

### Where This Executes

üëâ Inside Notification API service, synchronous HTTP/gRPC thread.


### Responsibilities (Strict)
    
The Notification API:

* ‚úÖ validates request
* ‚úÖ applies rate limits
* ‚úÖ generates notificationId
* ‚úÖ enqueues messages to Kafka
* ‚ùå does NOT send notifications
* ‚ùå does NOT retry
* ‚ùå does NOT call providers

### Pseudocode

```text
Validate request
Apply rate limits

/**

Expand channels
Build messages
Publish to notification.main
Return ACCEPTED

**/

for channel in request.channels:
    msg = buildMessage(channel)
    kafka.produce("notification.main", key=userId, msg)
```

---


## 6. Rate Limiting (Critical and Explicit)

### Why Rate Limiting Exists

Rate limiting is **not for performance.**

It is for:

* preventing user spam
* preventing OTP brute force
* preventing provider bans
* preventing financial loss (SMS cost)

---

### Where Rate Limiting MUST Happen

```text
Order Service ‚Üí Notification API ‚Üí Kafka
                      ‚Üë
                RATE LIMIT HERE
```



* Never in workers.
* Never after retries.
* Never at providers.


### Why Workers Must NOT Rate Limit

Workers see:

* original messages
* retry messages
* re-deliveries

They **cannot distinguish intent from retry.**

Rate limiting must apply **once per intent**, before Kafka.


### Rate Limiting Dimensions

| Dimension   | Example          |
|-------------|------------------|
| Per user    | 5 SMS / hour     |
| Per channel | SMS < Email      |
| Per event   | OTP < Marketing  |
| Per IP      | Abuse protection |
| Global      | Provider quota   |

---

### Rate Limiting Pseudocode (Notification API)

```text
validate(request)

if rateLimitExceeded(userId, event, channel):
    reject request

proceed to enqueue
```


## 7. How notificationId Is Generated (Explicit)

### Where It Happens

üëâ Inside Notification API, after validation and rate limiting.

---

### How It Is Generated

```text
notificationId = UUIDv4()
```

* Generated once
* Represents notification intent
* Copied unchanged across retries, DLQ, replays

Workers **never generate IDs**.


## 8. Canonical Notification Message (Final)

> One message = one channel
> 

```json
{
  "notificationId": "uuid",
  "userId": 101,
  "event": "ORDER_CONFIRMED",
  "channel": "EMAIL",
  "templateId": "order_confirmed_v1",
  "payload": {
    "orderId": 456
  },
  "retries": 0,
  "maxRetries": 3,
  "createdAt": 1730000000
}
```


## 9. Kafka Topic Design (Time as State)

Kafka does not support delayed messages.

So time is modeled using topics.

```text
notification.main
notification.retry.1m
notification.retry.5m
notification.retry.30m
notification.dlq
```

Each topic represents **a delivery stage**, not priority.


## 10. Partitioning Strategy

```text
partitionKey = userId
```

Guarantees:

* ordering per user
* correct OTP sequencing
* no concurrent spam


## 11. Idempotency (Correctly Explained)

### Core Problem

Kafka is at-least-once:

* messages can be re-delivered
* workers can crash
* retries re-execute logic

---

### What Idempotency Means Here
> Re-processing the same message must **not cause repeated side effects**.
> 

### How It Works

After successful delivery, the worker records:

```text
notification:{notificationId} = SENT   (TTL = 24 hours)
```

Stored in Redis.

If Redis entry exists ‚Üí **do not send again**.

TTL is intentional:
    
* memory is bounded
* cost is controlled
* rare duplicates are acceptable


## 12. Notification Worker (Execution Layer)

### Where This Executes

üëâ Inside Kafka consumer threads of Notification Worker service.

Workers are stateless.

State lives in:

* Kafka (message)
* Redis (idempotency memory)


## 13. Worker Execution Logic (Exact)

```text
record = kafkaConsumer.poll()

try:
    id = record.notificationId

    // Idempotency check
    if redis.exists("notification:" + id):
        kafkaConsumer.commit()
        return

    // Provider call (side effect)
    response = provider.send(record)

    if response == 200:
        redis.set("notification:" + id, TTL=24h)
        kafkaConsumer.commit()

    else if response in 4xx:
        kafkaProducer.produce("notification.dlq", record)
        kafkaConsumer.commit()

    else if response == 429 or response in 5xx:
        record.retries++

        if record.retries <= record.maxRetries:
            nextTopic = mapRetryTopic(record.retries)
            kafkaProducer.produce(nextTopic, record)
        else:
            kafkaProducer.produce("notification.dlq", record)

        kafkaConsumer.commit()

catch Exception:
    // NO commit
    // Kafka will redeliver
```


## 14. Provider Response Handling (Meaning) 

| Provider Response | Meaning           | Action    |
|-------------------|-------------------|-----------|
| 200 OK            | Accepted          | Mark sent |
| 4xx               | Permanent error   | DLQ       |
| 429               | Throttled         | Retry     |
| 5xx / timeout     | Temporary failure | Retry     |


Rule:
>
> Retry only when the failure is temporary.
> 


## 15. Retry Topic Mapping

```text
1 retry  ‚Üí notification.retry.1m
2 retries ‚Üí notification.retry.5m
3 retries ‚Üí notification.retry.30m
>3 retries ‚Üí notification.dlq
```

Delay is handled by consumer configuration, not sleep.


## 16. Offset Commit Strategy

* Auto-commit disabled
* Manual commit only
* Commit after side effects


* Kafka = at-least-once
* System behavior = **effectively-once**


## 17. Guarantees (Be Precise)

### What the system guarantees

> The system will not intentionally send the same notification more than once for the
> same notificationId within the idempotency window.
> 

### What it does NOT guarantee

* Perfect at-most-once
* Zero duplicates under network ambiguity

Correct term:

>
> Effectively-once delivery
>


## 18. Failure Scenarios

| Failure           | Outcome            |
|-------------------|--------------------|
| Worker crash      | Kafka redelivery   |
| Provider outage   | Retries absorb     |
| Redis key expired | Possible duplicate |
| Kafka down        | API rejects        |

All understood and controlled.

