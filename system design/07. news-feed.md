# News Feed System Design (Interview-Ready, Step by Step)

---

## 1. Start From the User's Point of View (Always First)

Before talking about databases or Kafka, define **what the user experiences**.

When a user opens the app:

1. They immediately see a list of posts
2. Posts come from people they follow
3. Posts are ordered (usually newest first)
4. Scrolling loads more posts
5. New posts appear after some time

This is the **contract** of the system.

---

## 2. Reduce the Problem to One Sentence

> **Given a user, efficiently return a personalized, ordered list of posts created by people they follow.**

Everything in the design exists to solve this sentence **at scale**.

---

## 3. The Most Important Observation (Drives Everything)

Ask:

> Do users read feeds more often, or create posts more often?

Reality in all social systems:

```
Feed reads  >>  Post writes
(usually 50â€“100x more reads)
```

### Consequence

ðŸ‘‰ **We must optimize for fast reads**, even if writes become more complex.

This single insight drives:

* fan-out decisions
* storage layout
* caching strategy

---

## 4. Identify the Core Data (No Assumptions)

### 4.1 Post (stored once)

A post is immutable and stored only once.

```json
{
  "postId": 9001,
  "authorId": 1,
  "content": "Hello world",
  "createdAt": 1700000000
}
```

Stored in a **Post Store** (SQL or NoSQL).

---

### 4.2 Follow Graph

We need to know **who follows whom**.

Example:

```
Alice (1) followers â†’ [Bob (2), Carol (3)]
```

Managed by a **Follow Service**.

---

### 4.3 Feed (per user)

A feed is **not posts**, it is **references**.

```
feed:userId = ordered list of postIds
```

Example:

```
feed:Bob = [9001, 8005, 7999, ...]
```

Important:

* Ordered
* Append-only
* Bounded (e.g., last 1000 items)

---

## 5. The Naive Approach (Explain Why It Fails)

### Fan-out on Read (Pull Model)

When Bob opens the feed:

1. Fetch everyone Bob follows
2. Fetch recent posts from each
3. Merge and sort in real time

### Why it fails

* Hundreds of reads per request
* Large in-memory merge
* Slow latency
* Does not scale

âŒ Rejected.

---

## 6. Key Idea: Fan-out on Write (Push Model)

Instead of computing feeds when users read:

> **Precompute feeds when posts are created.**

This shifts work from **read time** to **write time**.

---

## 7. Fan-out on Write (Normal User â€“ Step by Step)

### Example Setup

* Alice (userId=1) â†’ normal user
* Bob (2) and Carol (3) follow Alice

---

### Step 1: Alice Creates a Post

Synchronous steps:

1. Validate request
2. Store post in Post DB
3. Emit event

```
PostCreated {
  postId = 9001
  authorId = 1
  createdAt = T1
}
```

Alice's request finishes here.

---

### Step 2: Fan-out Worker Consumes Event

Asynchronously.

---

### Step 3: Fetch Followers

```
getFollowers(1) â†’ [2, 3]
```

---

### Step 4: Update Each Feed

Bob's feed before:

```
[8005, 7999]
```

After:

```
[9001, 8005, 7999]
```

Carol's feed updated similarly.

---

### Result

* Post stored once
* Feed references updated
* Reads become trivial

---

## 8. Feed Read (Normal User)

Bob opens feed:

```
GET /feed?limit=3
```

Steps:

1. Read `feed:Bob` from Redis
2. Take first 3 postIds
3. Fetch post metadata
4. Return result

No merge. No sort. Very fast.

---

## 9. Pagination (Cursor-Based, Correct Way)

### Why offset pagination fails

```
?page=2
```

Fails when new posts arrive â†’ duplicates or gaps.

---

### Cursor pagination

Cursor = **timestamp or postId of last item**.

Example response:

```json
{
  "items": [9001, 8005, 7999],
  "nextCursor": 7999
}
```

Next request:

```
GET /feed?limit=3&cursor=7999
```

Meaning:

> â€œGive me posts older than this.â€

---

## 10. The Celebrity Problem (Why Fan-out on Write Breaks)

Now change **one variable**.

Alice has:

```
5,000,000 followers
```

Fan-out on write would require:

```
5 million feed updates per post
```

âŒ Impossible.

---

## 11. Celebrity Rule (Explicit and Deterministic)

```
If followerCount > threshold (e.g. 100k)
â†’ treat user as CELEBRITY
```

This decision is made **at post creation time**.

---

## 12. Fan-out on Read (Celebrity Write Path)

### Step 1: Celebrity Creates Post

Same as normal:

* Store post
* Emit event

---

### Step 2: Worker Detects Celebrity

```
isCelebrity(authorId) â†’ true
```

---

### Step 3: No Fan-out Happens

Instead, store in a **celebrity timeline**:

```
celebrity_posts:Alice = [9100, 9090, 9080]
```

Follower feeds remain unchanged.

---

## 13. Feed Read With Celebrities (Merge Logic)

### Scenario

Bob follows:

* Normal users â†’ precomputed feed
* 1000 celebrities â†’ no precomputed fan-out

---

### Step 1: Fetch Normal Feed Slice

```
normalFeed = [N1, N2, N3, ... N20]
```

---

### Step 2: Fetch One Post per Celebrity

For each celebrity Ci:

```
celebrity_posts:Ci[0]
```

We fetch **only the most recent post**, not the whole list.

---

### Step 3: Build Candidate Set

```
candidates =
  normalFeed (20)
+ celebrityTopPosts (1000)
```

Bounded and predictable.

---

### Step 4: Merge and Sort

* Use a max-heap ordered by `createdAt`
* Pop top 20 items

Result:

```
[postA, postB, postC, ... postT]
```

Mixed normal + celebrity posts, globally ordered.

---

## 14. Pagination With Celebrities (Why Timestamp Matters)

The cursor returned is:

```
lastTimestamp = timestamp of last post
```

Next request:

```
GET /feed?limit=20&cursor=lastTimestamp
```

### What happens next

For **every source**:

* Normal feed â†’ filter posts older than cursor
* Each celebrity timeline â†’ pick first post older than cursor

Then merge again.

### Key insight

> **Timestamp defines a global boundary**, so we don't need per-source indexes for correctness.

---

## 15. Why Indexes Are Optional (Important Interview Point)

* Per-celebrity offsets are an optimization
* Timestamp cursor alone guarantees correctness
* API remains stateless
* Indexes can be added later for performance

You were correct to drop them for interviews.

---

## 16. What If Follower Count Is 20k?

Talking about **post creation**:

At 20k followers:

* Fan-out on write is still cheap
* Writes happen once
* Reads happen many times

So at ~20k:

> **We still fan-out on write when a new post is created.**

Merge-on-read is a **scalability escape hatch**, not the default.

---

## 17. Architecture Diagram (Clean and Explainable)

```
Client
  |
API Gateway
  |
Feed Service  <------------------+
  |                               |
  |                               |
Post Service                       |
  |                               |
  v                               |
Event Bus (Kafka) ----------------+
  |
Fan-out Workers
  |
Feed Storage (Redis / DB)
```

* Normal users â†’ fan-out on write
* Celebrities â†’ fan-out on read
* Feed Service handles merge and pagination

---

## 18. Consistency Model

* Feed is **eventually consistent**
* New posts may appear after seconds
* Acceptable for social feeds

Strong consistency would kill scalability.

---

## 19. Failure Handling

| Failure          | Outcome               |
|------------------|-----------------------|
| Worker crash     | Event replay          |
| Partial fan-out  | Eventually consistent |
| Redis down       | Fallback to DB        |
| Duplicate events | Idempotent insert     |

---

## 20. One-Line Mental Model (Memorize)

> **Precompute feeds for normal users; lazily merge celebrity posts at read time using a timestamp cursor.**

---

## 21. Final Interview-Ready Summary

> A news feed is a read-heavy system, so we optimize for fast reads. For normal users, we use 
> fan-out on write by asynchronously pushing post references into followers' feeds, making 
> reads simple and fast. For celebrity users, fan-out on write becomes infeasible, so we 
> store their posts separately and merge them into followers' feeds at read time. Feed pagination 
> is cursor-based using timestamps, ensuring correctness without server-side state. The system is 
> eventually consistent, horizontally scalable, and resilient to failures.
> 

---

